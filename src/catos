/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   cleanup.c                                          :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: dloisel <dloisel@student.42.fr>            +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/12/12 07:34:21 by dloisel           #+#    #+#             */
/*   Updated: 2024/12/14 01:01:30 by dloisel          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../../includes/cub3d.h"

void destroy_textures(t_game *game)
{
	if (game->textures.north.img)
		mlx_destroy_image(game->mlx, game->textures.north.img);
	if (game->textures.south.img)
		mlx_destroy_image(game->mlx, game->textures.south.img);
	if (game->textures.east.img)
		mlx_destroy_image(game->mlx, game->textures.east.img);
	if (game->textures.west.img)
		mlx_destroy_image(game->mlx, game->textures.west.img);
}

void cleanup_game(t_game *game)
{
	if (game)
	{
		destroy_textures(game);
		if (game->img)
			mlx_destroy_image(game->mlx, game->img);

		if (game->win)
			mlx_destroy_window(game->mlx, game->win);

		if (game->mlx)
		{
			mlx_destroy_display(game->mlx);
			free(game->mlx);
		}
	}
}

int close_window(t_game *game)
{
	ft_free_map(game);
	cleanup_game(game);
	exit(0);
	return (0);
}

int	ft_error_handling(t_game *game, char *message)
{
	ft_free_map(game);
	cleanup_game(game);
	if (message)
	{
		ft_printf(RED "%s\n", "Error");
		ft_printf("%s\n" RESET, message);
	}
	exit(0);
	return (0);
}
#include "../../includes/cub3d.h"

void update_game_state(t_game *game)
{
    if (game->game_state == GAME_STATE_PLAYING)
    {
        game->current_time = time(NULL);
        int elapsed = game->current_time - game->start_time;
        
        // Mise à jour du fog toutes les 1.5 minutes
        game->fog_level = elapsed / FOG_INTERVAL;
        if (game->fog_level > MAX_FOG_LEVELS)
            game->fog_level = MAX_FOG_LEVELS;
            
        // Réduire la distance de vue en fonction du niveau de brouillard
        game->view_distance = BASE_VIEW_DISTANCE / (game->fog_level + 1);
        
        // Vérification du temps écoulé
        if (elapsed >= INITIAL_TIME)
            game->game_state = GAME_STATE_GAMEOVER;
    }
}//hooks.c

#include "../../includes/cub3d.h"

/* Gestion des touches */
int key_press(int keycode, t_game *game)
{
    if (game->game_state == GAME_STATE_MENU && keycode == 65293) // Touche Entrée
    {
        game->game_state = GAME_STATE_PLAYING;
        game->start_time = time(NULL);
        return (0);
    }
    if (game->game_state != GAME_STATE_PLAYING)
        return (0);
	if (keycode == 65307)        /* ESC */
        close_window(game);
    else if (keycode == 119)     /* W */
        game->move_forward = 1;
    else if (keycode == 115)     /* S */
        game->move_backward = 1;
    else if (keycode == 100)     /* D */
        game->rotate_right = 1;
    else if (keycode == 97)      /* A */
        game->rotate_left = 1;
    else if (keycode == 65361)   /* Flèche gauche */
        game->move_left = 1;
    else if (keycode == 65363)   /* Flèche droite */
        game->move_right = 1;
    return (0);
}

int key_release(int keycode, t_game *game)
{
    if (keycode == 119)          /* W */
        game->move_forward = 0;
    else if (keycode == 115)     /* S */
        game->move_backward = 0;
    else if (keycode == 100)     /* D */
        game->rotate_right = 0;
    else if (keycode == 97)      /* A */
        game->rotate_left = 0;
    else if (keycode == 65361)   /* Flèche gauche */
        game->move_left = 0;
    else if (keycode == 65363)   /* Flèche droite */
        game->move_right = 0;
    return (0);
}

void move_player(t_game *game)
{
    // Gestion du mouvement avant/arrière
    if (game->move_forward)
    {
        if (game->map.fullmap[(int)(game->player.pos_x + game->player.dir_x * MOVE_SPEED)]
                     [(int)game->player.pos_y] != '1')
            game->player.pos_x += game->player.dir_x * MOVE_SPEED;
        if (game->map.fullmap[(int)game->player.pos_x]
                     [(int)(game->player.pos_y + game->player.dir_y * MOVE_SPEED)] != '1')
            game->player.pos_y += game->player.dir_y * MOVE_SPEED;
    }
    if (game->move_backward)
    {
        if (game->map.fullmap[(int)(game->player.pos_x - game->player.dir_x * MOVE_SPEED)]
                     [(int)game->player.pos_y] != '1')
            game->player.pos_x -= game->player.dir_x * MOVE_SPEED;
        if (game->map.fullmap[(int)game->player.pos_x]
                     [(int)(game->player.pos_y - game->player.dir_y * MOVE_SPEED)] != '1')
            game->player.pos_y -= game->player.dir_y * MOVE_SPEED;
    }

    // Gestion de la rotation
    if (game->rotate_right || game->rotate_left)
    {
        double rot_speed = game->rotate_right ? -ROTATION_SPEED : ROTATION_SPEED;
        double old_dir_x = game->player.dir_x;
        double old_plane_x = game->player.plane_x;

        game->player.dir_x = game->player.dir_x * cos(rot_speed)
                          - game->player.dir_y * sin(rot_speed);
        game->player.dir_y = old_dir_x * sin(rot_speed)
                          + game->player.dir_y * cos(rot_speed);
        game->player.plane_x = game->player.plane_x * cos(rot_speed)
                            - game->player.plane_y * sin(rot_speed);
        game->player.plane_y = old_plane_x * sin(rot_speed)
                            + game->player.plane_y * cos(rot_speed);
    }

    // Gestion du mouvement latéral
    if (game->move_left)
    {
        if (game->map.fullmap[(int)(game->player.pos_x)]
                     [(int)(game->player.pos_y + game->player.dir_x * MOVE_SPEED)] != '1')
            game->player.pos_y += game->player.dir_x * MOVE_SPEED;
        if (game->map.fullmap[(int)(game->player.pos_x - game->player.dir_y * MOVE_SPEED)]
                     [(int)game->player.pos_y] != '1')
            game->player.pos_x -= game->player.dir_y * MOVE_SPEED;
    }
    if (game->move_right)
    {
        if (game->map.fullmap[(int)(game->player.pos_x)]
                     [(int)(game->player.pos_y - game->player.dir_x * MOVE_SPEED)] != '1')
            game->player.pos_y -= game->player.dir_x * MOVE_SPEED;
        if (game->map.fullmap[(int)(game->player.pos_x + game->player.dir_y * MOVE_SPEED)]
                     [(int)game->player.pos_y] != '1')
            game->player.pos_x += game->player.dir_y * MOVE_SPEED;
    }
}#include "../../includes/cub3d.h"

/* Initialisation */
void init_player_direction(t_game *game, char direction)
{
	printf("Setting player direction: %c\n", direction);

	game->move_forward = 0;
	game->move_backward = 0;
	game->move_left = 0;
	game->move_right = 0;
	game->rotate_left = 0;
	game->rotate_right = 0;

	game->fog_level = 0;
    game->view_distance = BASE_VIEW_DISTANCE;

	game->game_state = GAME_STATE_MENU;
    game->fog_intensity = 0;

	if (direction == 'N')
	{
		game->player.dir_x = -1.0;
		game->player.dir_y = 0.0;
		game->player.plane_x = 0.0;
		game->player.plane_y = 0.66;
	}
	else if (direction == 'S')
	{
		game->player.dir_x = 1.0;
		game->player.dir_y = 0.0;
		game->player.plane_x = 0.0;
		game->player.plane_y = -0.66;
	}
	else if (direction == 'E')
	{
		game->player.dir_x = 0.0;
		game->player.dir_y = 1.0;
		game->player.plane_x = 0.66;
		game->player.plane_y = 0.0;
	}
	else if (direction == 'W')
	{
		game->player.dir_x = 0.0;
		game->player.dir_y = -1.0;
		game->player.plane_x = -0.66;
		game->player.plane_y = 0.0;
	}
	printf("Player direction set to: dir_x=%f, dir_y=%f, plane_x=%f, plane_y=%f\n",
		   game->player.dir_x, game->player.dir_y, game->player.plane_x, game->player.plane_y);
}

void find_player_position(t_game *game)
{
	int	i;
	int	j;

	i = 0;
	printf("Searching for player position...\n");
	while (game->map.fullmap[i])
	{
		j = 0;
		while (game->map.fullmap[i][j])
		{
			printf("%c", game->map.fullmap[i][j]);  // Debug: afficher la carte
			if (game->map.fullmap[i][j] == 'N' || game->map.fullmap[i][j] == 'S' ||
				game->map.fullmap[i][j] == 'E' || game->map.fullmap[i][j] == 'W')
			{
				printf("\nFound player at position: %d, %d (symbol: %c)\n",
					   i, j, game->map.fullmap[i][j]);
				game->player.pos_x = i + 0.5;  // Centre le joueur dans la case
				game->player.pos_y = j + 0.5;
				init_player_direction(game, game->map.fullmap[i][j]);
				game->map.fullmap[i][j] = '0';  // Libère la case
				return;
			}
			j++;
		}
		i++;
		printf("\n");  // Debug: nouvelle ligne pour la carte
	}
	printf("Player position not found!\n");
}

void init_game(t_game *game)
{
	int bpp = 32;
	int size_line = WINDOW_WIDTH * 4;  // 4 octets par pixel
	int endian = 0;
	int	i;

	game->mlx = mlx_init();
	if (!game->mlx)
	{
		printf("Error: mlx initialization failed\n");
		exit(1);
	}

	game->win = mlx_new_window(game->mlx, WINDOW_WIDTH, WINDOW_HEIGHT, "Cub3D");
	if (!game->win)
	{
		printf("Error: window creation failed\n");
		exit(1);
	}

	game->img = mlx_new_image(game->mlx, WINDOW_WIDTH, WINDOW_HEIGHT);
	if (!game->img)
	{
		printf("Error: image creation failed\n");
		mlx_destroy_window(game->mlx, game->win);
		exit(1);
	}

	game->addr = mlx_get_data_addr(game->img, &bpp, &size_line, &endian);
	if (!game->addr)
	{
		printf("Error: getting image address failed\n");
		mlx_destroy_image(game->mlx, game->img);
		mlx_destroy_window(game->mlx, game->win);
		exit(1);
	}

	game->bits_per_pixel = bpp;
	game->line_length = size_line;
	game->endian = endian;
	game->addr = mlx_get_data_addr(game->img, &bpp, &size_line, &endian);
	if (!game->addr)
	{
		printf("Error: getting image address failed\n");
		mlx_destroy_image(game->mlx, game->img);
		mlx_destroy_window(game->mlx, game->win);
		exit(1);
	}

	game->bits_per_pixel = bpp;
	game->line_length = size_line;
	game->endian = endian;

	if (!load_textures(game))
		ft_error_handling(game, "loading textures failed");

	find_player_position(game);
	init_minimap(game);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   main.c                                             :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: dloisel <dloisel@student.42.fr>            +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/12/12 07:24:01 by dloisel           #+#    #+#             */
/*   Updated: 2024/12/14 01:01:32 by dloisel          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../includes/cub3d.h"

/* Point d'entrée */
int main(int argc, char **argv)
{
	t_game game;

	// Initialiser la structure à zéro
	ft_memset(&game, 0, sizeof(t_game));

	ft_parsing(argc, argv, &game);
	// Initialiser le jeu
	init_game(&game);

	if (!game.mlx || !game.win || !game.img || !game.addr)
	{
		cleanup_game(&game);
		return (1);
	}

	// Configurer les hooks
	mlx_hook(game.win, 2, 1L<<0, key_press, &game);
	mlx_hook(game.win, 17, 0, close_window, &game);
	mlx_hook(game.win, 3, 1L<<1, key_release, &game);
	mlx_loop_hook(game.mlx, render, &game);

	// Démarrer la boucle principale
	mlx_loop(game.mlx);

	return (0);
}

// void debug_print_map(t_game *game)
// {
//     printf("Current map state:\n");
//     for (int i = 0; i < game->map_height; i++)
//     {
//         for (int j = 0; j < game->map_width; j++)
//         {
//             printf("%c ", game->map[i][j]);
//         }
//         printf("\n");
//     }
//     printf("Player position: x=%f, y=%f\n", game->player.pos_x, game->player.pos_y);
//     printf("Player direction: dx=%f, dy=%f\n", game->player.dir_x, game->player.dir_y);
// }
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   arg_verif.c                                        :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: dloisel <dloisel@student.42.fr>            +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/10/24 19:04:14 by dloisel           #+#    #+#             */
/*   Updated: 2024/12/12 07:18:42 by dloisel          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../../includes/cub3d.h"

int	ft_strcmp(char *s1, char *s2)
{
	int	i;

	i = 0;
	while ((s1[i] == s2[i]) && (s1[i] != '\0' || s2[i] != '\0'))
		i++;
	return ((unsigned char)s1[i] - (unsigned char)s2[i]);
}

void	ft_arg_verif(int argc, char **argv, t_game *game)
{
	char	*format;
	int		len;

	format = ".cub";
	if (argc != 2)
	{
		if (argc > 2)
			ft_error_map("Only 1 argument please.", game);
		else
			ft_error_map("There must be at least 1 argument.", game);
		return ;
	}
	len = ft_strlen(argv[1]);
	if (len < 4)
	{
		ft_error_map("The map file must be in .cub format.", game);
		return ;
	}
	if (ft_strcmp(argv[1] + len - 4, format) != 0)
	{
		ft_error_map("The map file must be in .cub format.", game);
		return ;
	}
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   free_parsing.c                                     :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: dloisel <dloisel@student.42.fr>            +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/10/25 16:36:06 by dloisel           #+#    #+#             */
/*   Updated: 2024/12/13 19:35:26 by dloisel          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../../includes/cub3d.h"

void	ft_free_array(char **array)
{
	int	i;

	if (!array)
		return ;
	i = 0;
	while (array[i])
	{
		free(array[i]);
	i++;
	}
	free(array);
	array = NULL;
}

void	ft_error_map(char *msg, t_game *game)
{
	if (game->map.fullmap)
		ft_free_array(game->map.fullmap);
	if (msg)
	{
		ft_printf(RED "%s\n", "Error");
		ft_printf("%s\n" RESET, msg);
	}
	game->map.is_map_valid = 1;
}

void	ft_free_map(t_game *game)
{
	if (game->map.fullmap)
		ft_free_array(game->map.fullmap);
	if (game->map.no_texture)
		free(game->map.no_texture);
	if (game->map.so_texture)
		free(game->map.so_texture);
	if (game->map.we_texture)
		free(game->map.we_texture);
	if (game->map.ea_texture)
		free(game->map.ea_texture);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   map_check1.c                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: dloisel <dloisel@student.42.fr>            +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/10/25 16:57:44 by dloisel           #+#    #+#             */
/*   Updated: 2024/12/12 07:20:33 by dloisel          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../../includes/cub3d.h"

void	ft_wall_check3(t_game *game)
{
	int	i;
	int	j;

	i = 1;
	if (game->map.is_map_valid == 1)
		return ;
	while (game->map.fullmap[i + 1] != NULL)
	{
		j = 1;
		while (game->map.fullmap[i][j + 1] != '\0')
		{
			if (game->map.fullmap[i][j] == '0' \
			&& !ft_zero_map_check(game->map.fullmap, i, j))
				return ((void)ft_error_map("Missing wall within the map.", \
				game));
			j++;
		}
		i++;
	}
}

void	ft_wall_check2(t_game *game)
{
	int		i;
	int		j;
	size_t	len;

	i = 0;
	if (game->map.is_map_valid == 1)
		return ;
	while (game->map.fullmap[i])
	{
		j = 0;
		len = ft_strlen(game->map.fullmap[i]);
		while (game->map.fullmap[i][j] == ' ')
			j++;
		if (game->map.fullmap[i][j] != '1' && game->map.fullmap[i][j] != ' ')
			return ((void)ft_error_map("Missing wall on the \
left side of the map.", game));
		if (game->map.fullmap[i][len - 1] != '1' \
		&& game->map.fullmap[i][len - 1] != ' ')
			return ((void)ft_error_map("Missing wall on the \
right side of the map.", game));
		i++;
	}
}

void	ft_wall_check1(t_game *game)
{
	int	i;
	int	j;

	i = 0;
	j = 0;
	if (game->map.is_map_valid == 1)
		return ;
	while (game->map.fullmap[0][i])
	{
		if (game->map.fullmap[0][i] != '1' && game->map.fullmap[0][i] != ' ')
			return ((void)ft_error_map("Missing wall in the \
first row of the map.", game));
		i++;
	}
	i = 0;
	while (game->map.fullmap[i])
		i++;
	i--;
	while (game->map.fullmap[i][j])
	{
		if (game->map.fullmap[i][j] != '1' && game->map.fullmap[i][j] != ' ')
			return ((void)ft_error_map("Missing wall in the last \
row of the map.", game));
		j++;
	}
}

void	ft_emptyline_check(t_game *game)
{
	int	i;
	int	j;
	int	is_empty;

	i = 0;
	while (game->map.fullmap[i])
	{
		j = 0;
		is_empty = 1;
		while (game->map.fullmap[i][j])
		{
			if (game->map.fullmap[i][j] != '\n' && \
			game->map.fullmap[i][j] != ' ')
			{
				is_empty = 0;
				break ;
			}
			j++;
		}
		if (is_empty)
			return ((void)ft_error_map("Empty line in the map.", game));
		i++;
	}
}

void	ft_map_check(t_game *game)
{
	if (game->map.is_map_valid == 1)
		return ;
	if (!game->map.fullmap)
		return ((void)ft_error_handling(game, "No map in the .cub file."));
	ft_emptyline_check(game);
	ft_invalid_char_check(game);
	ft_wall_check1(game);
	ft_wall_check2(game);
	ft_wall_check3(game);
	ft_player_check(game, 0, 0);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   map_check2.c                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: dloisel <dloisel@student.42.fr>            +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/10/25 20:29:15 by dloisel           #+#    #+#             */
/*   Updated: 2024/12/13 19:41:53 by dloisel          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../../includes/cub3d.h"

void	ft_player_check(t_game *game, int i, int j)
{
	int	player_count;

	player_count = 0;
	if (game->map.is_map_valid == 1)
		return ;
	while (game->map.fullmap[i])
	{
		j = 0;
		while (game->map.fullmap[i][j])
		{
			if (game->map.fullmap[i][j] == 'N' || \
			game->map.fullmap[i][j] == 'S' || game->map.fullmap[i][j] == 'E' \
			|| game->map.fullmap[i][j] == 'W')
				player_count++;
			j++;
		}
		i++;
	}
	if (player_count == 0)
		return ((void)ft_error_map("No player is present within the map.", \
		game));
	else if (player_count > 1)
		return ((void)ft_error_map("Two or more players are present \
within the map, only one player is allowed to be on the map.", game));
}

void	ft_invalid_char_check(t_game *game)
{
	int	i;
	int	j;

	i = 0;
	while (game->map.fullmap[i])
	{
		j = 0;
		while (game->map.fullmap[i][j])
		{
			if (game->map.fullmap[i][j] != '1' && game->map.fullmap[i][j] != '0'
			&& game->map.fullmap[i][j] != ' ' && game->map.fullmap[i][j] != 'N'
			&& game->map.fullmap[i][j] != 'W' && game->map.fullmap[i][j] != 'E'
			&&game->map.fullmap[i][j] != 'S')
				return ((void)ft_error_map("Invalid character within the map.", \
				game));
			j++;
		}
		i++;
	}
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   map_init.c                                         :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: dloisel <dloisel@student.42.fr>            +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/10/24 19:32:33 by dloisel           #+#    #+#             */
/*   Updated: 2024/12/12 07:17:40 by dloisel          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../../includes/cub3d.h"

void	ft_extract_map(t_game *game, char *buff, int j, char **temp)
{
	static int	i;

	j = 0;
	if (buff[0] == '\n' && game->map.fullmap == NULL)
		return ;
	temp = game->map.fullmap;
	game->map.fullmap = malloc(sizeof(char *) * (i + 2));
	if (!game->map.fullmap)
		ft_error_map("Allocation error.", game);
	ft_copy_previous_map(game->map.fullmap, temp, i);
	game->map.fullmap[i] = malloc(sizeof(char) * (ft_strlen(buff) + 1));
	if (!game->map.fullmap[i])
		return (free(game->map.fullmap), \
		(void)ft_error_map("Allocation error.", game));
	j = 0;
	while (buff[j] && buff[j] != '\n')
	{
		game->map.fullmap[i][j] = buff[j];
		j++;
	}
	game->map.fullmap[i][j] = '\0';
	game->map.fullmap[i + 1] = NULL;
	i++;
	if (temp)
		free(temp);
}

char	*ft_extract_line_info(char *buff, t_game *game)
{
	int		i;
	int		j;
	int		k;
	char	*info;

	i = 0;
	k = 0;
	game->map.all_info++;
	while (buff[i] == 'N' || buff[i] == 'S' || buff[i] == 'W' || buff[i] == 'E'
		|| buff[i] == 'A' || buff[i] == 'O' || buff[i] == ' ')
		i++;
	j = i;
	while (buff[i] != ' ' && buff[i] != '\n' && buff[i] != '\0')
		i++;
	info = malloc(sizeof(char) * ((i - j) + 1));
	if (!info)
		return (ft_error_map("Allocation error.", game), NULL);
	while (j < i)
	{
		info[k] = buff[j];
		k++;
		j++;
	}
	info[k] = '\0';
	return (info);
}

int	ft_extract_color(char *buff, t_game *game)
{
	int	r;
	int	g;
	int	b;

	game->map.all_info++;
	while (*buff == 'F' || *buff == 'C' || *buff == ' ')
		buff++;
	r = ft_atoi(buff);
	while (*buff && *buff != ',')
		buff++;
	buff++;
	g = ft_atoi(buff);
	while (*buff && *buff != ',')
		buff++;
	buff++;
	b = ft_atoi(buff);
	if (r < 0 || r > 255 || g < 0 || g > 255 || b < 0 || b > 255)
		return (ft_error_map("RGB values are incorrect.", game), 0);
	return (ft_rgb_to_int(r, g, b));
}

void	ft_extract_info(t_game *game, char *buff)
{
	while (*buff == ' ' || *buff == '\t')
		buff++;
	if (!ft_strncmp(buff, "NO ", 3))
		game->map.no_texture = ft_extract_line_info(buff, game);
	else if (!ft_strncmp(buff, "SO ", 3))
		game->map.so_texture = ft_extract_line_info(buff, game);
	else if (!ft_strncmp(buff, "WE ", 3))
		game->map.we_texture = ft_extract_line_info(buff, game);
	else if (!ft_strncmp(buff, "EA ", 3))
		game->map.ea_texture = ft_extract_line_info(buff, game);
	else if (!ft_strncmp(buff, "F ", 2))
		game->map.floor_color = ft_extract_color(buff, game);
	else if (!ft_strncmp(buff, "C ", 2))
		game->map.ceiling_color = ft_extract_color(buff, game);
}

void	ft_map_init(t_game *game, char *argv, int fd)
{
	char	*buff;

	if (game->map.is_map_valid == 1)
		return ;
	fd = open(argv, O_RDONLY);
	if (fd == -1)
		ft_error_map("The map couldn't be opened.", game);
	while (1)
	{
		buff = get_next_line(fd);
		if (buff == NULL)
			break ;
		if (!ft_is_map_line(buff) && game->map.all_info < 6)
			ft_extract_info(game, buff);
		else
			ft_extract_map(game, buff, 0, NULL);
		free(buff);
	}
	if (game->map.all_info < 6)
		ft_error_map("Missing elements in .cub file (NO, SO, WE, EA, F, C).",
			game);
	close(fd);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   parsing.c                                          :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: dloisel <dloisel@student.42.fr>            +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/10/24 19:12:16 by dloisel           #+#    #+#             */
/*   Updated: 2024/12/13 20:15:21 by dloisel          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../../includes/cub3d.h"

void	ft_struct_map_init(t_game *game)
{
	game->map.fullmap = NULL;
	game->map.width = 0;
	game->map.height = 0;
	game->map.is_map_valid = 0;
	game->map.all_info = 0;
	game->map.player_x = -1;
	game->map.player_y = -1;
	game->map.player_dir = '\0';
	game->map.floor_color = 0;
	game->map.ceiling_color = 0;
}

void	ft_get_width_height(t_game *game)
{
	int	i;
	int	j;

	i = 0;
	j = 0;
	if (game->map.is_map_valid == 1)
		return ;
	while (game->map.fullmap[i])
	{
		while (game->map.fullmap[i][j])
			j++;
		if (game->map.width < j)
			game->map.width = j;
		i++;
	}
	game->map.height = i;
}

void	ft_parsing(int argc, char **argv, t_game *game)
{
	ft_struct_map_init(game);
	ft_arg_verif(argc, argv, game);
	ft_map_init(game, argv[1], 0);
	ft_map_check(game);
	ft_get_width_height(game);
	if (game->map.is_map_valid == 1)
		ft_error_handling(game, NULL);
}
// Je check chaque ligne si le premier et dernier caractère est un 1
// Si je croise un espace je regarde si il est
// Je check chaque 0 si il est entouré de soit un 0 ou un 1
// Je check chaque espace si il est entouré de soit un 1 ou un autre espace
// Défauts du parsing :
//	- Si la première ou derniére ligne a des 0 qui dépassent alors la map est
//		alors que la map est techniquement jouable.
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   parsing_utils.c                                    :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: dmathis <dmathis@student.42.fr>            +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/10/25 10:24:15 by dloisel           #+#    #+#             */
/*   Updated: 2024/10/29 22:01:00 by dmathis          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../../includes/cub3d.h"

int	ft_rgb_to_int(int r, int g, int b)
{
	return ((r << 16) | (g << 8) | b);
}

int	ft_is_map_line(char *line)
{
	int	i;
	int	has_valid_char;

	i = 0;
	has_valid_char = 0;
	while (line[i])
	{
		if (line[i] == '\n')
			break ;
		if (line[i] != ' ' && line[i] != '1' && line[i] != '0' && \
		line[i] != 'N' && line[i] != 'S' && line[i] != 'E' && line[i] != 'W')
			return (0);
		if (line[i] != ' ')
			has_valid_char = 1;
		i++;
	}
	return (has_valid_char);
}

void	ft_copy_previous_map(char **new_map, char **old_map, int size)
{
	int	j;

	j = 0;
	while (old_map && old_map[j] && j < size)
	{
		new_map[j] = old_map[j];
		j++;
	}
}

int	ft_zero_map_check(char **map, int i, int j)
{
	if ((map[i - 1][j] != '1' && map[i - 1][j] != '0' && map[i - 1][j] != 'N' &&
		map[i - 1][j] != 'S' && map[i - 1][j] != 'W' && map[i - 1][j] != 'E') ||
		(map[i + 1][j] != '1' && map[i + 1][j] != '0' && map[i + 1][j] != 'N' &&
		map[i + 1][j] != 'S' && map[i + 1][j] != 'W' && map[i + 1][j] != 'E') ||
		(map[i][j - 1] != '1' && map[i][j - 1] != '0' && map[i][j - 1] != 'N' &&
		map[i][j - 1] != 'S' && map[i][j - 1] != 'W' && map[i][j - 1] != 'E') ||
		(map[i][j + 1] != '1' && map[i][j + 1] != '0' && map[i][j + 1] != 'N' &&
		map[i][j + 1] != 'S' && map[i][j + 1] != 'W' && map[i][j + 1] != 'E'))
		return (0);
	return (1);
}
//raycasting.c

#include "../../includes/cub3d.h"

/* Fonction principale de raycasting avec textures */
#include "../../includes/cub3d.h"

/* Fonction principale de raycasting avec textures et brouillard */
void raycasting(t_game *game)
{
    for (int x = 0; x < WINDOW_WIDTH; x++)
    {
        // Calcul de la direction du rayon
        double camera_x = 2 * x / (double)WINDOW_WIDTH - 1;
        double ray_dir_x = game->player.dir_x + game->player.plane_x * camera_x;
        double ray_dir_y = game->player.dir_y + game->player.plane_y * camera_x;

        // Position actuelle sur la carte
        int map_x = (int)game->player.pos_x;
        int map_y = (int)game->player.pos_y;

        // Longueur du rayon d'un côté à l'autre
        double delta_dist_x = fabs(1 / ray_dir_x);
        double delta_dist_y = fabs(1 / ray_dir_y);

        // Variables pour l'algorithme DDA
        double side_dist_x;
        double side_dist_y;
        int step_x;
        int step_y;
        int hit = 0;
        int side;

        // Calcul du pas et de la distance initiale
        if (ray_dir_x < 0)
        {
            step_x = -1;
            side_dist_x = (game->player.pos_x - map_x) * delta_dist_x;
        }
        else
        {
            step_x = 1;
            side_dist_x = (map_x + 1.0 - game->player.pos_x) * delta_dist_x;
        }
        if (ray_dir_y < 0)
        {
            step_y = -1;
            side_dist_y = (game->player.pos_y - map_y) * delta_dist_y;
        }
        else
        {
            step_y = 1;
            side_dist_y = (map_y + 1.0 - game->player.pos_y) * delta_dist_y;
        }

        // Algorithme DDA (Digital Differential Analysis)
        while (hit == 0)
        {
            if (side_dist_x < side_dist_y)
            {
                side_dist_x += delta_dist_x;
                map_x += step_x;
                side = 0;
            }
            else
            {
                side_dist_y += delta_dist_y;
                map_y += step_y;
                side = 1;
            }

            // Vérification des limites de la carte
            if (map_x < 0 || map_x >= game->map.height || map_y < 0)
                break;

            // Vérification de la longueur de la ligne actuelle
            size_t row_length = ft_strlen(game->map.fullmap[map_x]);
            if (map_y >= row_length)
                break;

            // Vérification de collision avec un mur
            if (game->map.fullmap[map_x][map_y] == '1')
                hit = 1;
        }

        // Calcul de la distance au mur (perpendiculaire)
        double perp_wall_dist;
        if (side == 0)
            perp_wall_dist = (map_x - game->player.pos_x + (1 - step_x) / 2) / ray_dir_x;
        else
            perp_wall_dist = (map_y - game->player.pos_y + (1 - step_y) / 2) / ray_dir_y;

        // Application du brouillard basé sur la distance
        double fog_factor = 1.0;
        if (game->fog_level > 0)
        {
            fog_factor = 1.0 - (perp_wall_dist / game->view_distance);
            if (fog_factor < 0)
                fog_factor = 0;
            if (fog_factor > 1)
                fog_factor = 1;
        }

        // Calcul de la hauteur du mur à l'écran
        int line_height = (int)(WINDOW_HEIGHT / perp_wall_dist);

        // Calcul des pixels le plus bas et le plus haut à remplir
        int draw_start = -line_height / 2 + WINDOW_HEIGHT / 2;
        if (draw_start < 0)
            draw_start = 0;
        int draw_end = line_height / 2 + WINDOW_HEIGHT / 2;
        if (draw_end >= WINDOW_HEIGHT)
            draw_end = WINDOW_HEIGHT - 1;

        // Calcul de la coordonnée x du mur (pour la texture)
        double wall_x;
        if (side == 0)
            wall_x = game->player.pos_y + perp_wall_dist * ray_dir_y;
        else
            wall_x = game->player.pos_x + perp_wall_dist * ray_dir_x;
        wall_x -= floor(wall_x);

        // Calcul des coordonnées de texture
        int tex_x = (int)(wall_x * TEX_WIDTH);
        if (side == 0 && ray_dir_x > 0)
            tex_x = TEX_WIDTH - tex_x - 1;
        if (side == 1 && ray_dir_y < 0)
            tex_x = TEX_WIDTH - tex_x - 1;

        // Sélection de la texture selon le côté du mur
        t_texture *texture;
        if (side == 0)
            texture = ray_dir_x > 0 ? &game->textures.east : &game->textures.west;
        else
            texture = ray_dir_y > 0 ? &game->textures.south : &game->textures.north;

        // Calcul du pas de texture et de la position de départ
        double step = 1.0 * TEX_HEIGHT / line_height;
        double tex_pos = (draw_start - WINDOW_HEIGHT / 2 + line_height / 2) * step;

        // Dessin du mur texturé avec brouillard
        for (int y = draw_start; y < draw_end; y++)
        {
            int tex_y = (int)tex_pos & (TEX_HEIGHT - 1);
            tex_pos += step;

            int color = get_texture_color(texture, tex_x, tex_y);

            // Assombrir les côtés y
            if (side == 1)
                color = (color >> 1) & 0x7F7F7F;

            // Appliquer le brouillard
            if (game->fog_level > 0)
            {
                int fog_color = 0x808080;  // Couleur grise du brouillard
                int r = ((color & 0xFF0000) >> 16) * fog_factor + ((fog_color & 0xFF0000) >> 16) * (1 - fog_factor);
                int g = ((color & 0x00FF00) >> 8) * fog_factor + ((fog_color & 0x00FF00) >> 8) * (1 - fog_factor);
                int b = (color & 0x0000FF) * fog_factor + (fog_color & 0x0000FF) * (1 - fog_factor);
                color = (r << 16) | (g << 8) | b;
            }

            put_pixel(game, x, y, color);
        }

        // Distance de brouillard pour le sol et le plafond
        double floor_fog_start = game->view_distance * 0.5;  // Le brouillard commence à mi-chemin

        // Dessin du plafond avec brouillard
        for (int y = 0; y < draw_start; y++)
        {
            double ray_dir_x0 = game->player.dir_x - game->player.plane_x;
            double ray_dir_y0 = game->player.dir_y - game->player.plane_y;
            double ray_dir_x1 = game->player.dir_x + game->player.plane_x;
            double ray_dir_y1 = game->player.dir_y + game->player.plane_y;

            int p = y - WINDOW_HEIGHT / 2;
            double pos_z = 0.5 * WINDOW_HEIGHT;
            double row_distance = pos_z / p;

            double floor_step_x = row_distance * (ray_dir_x1 - ray_dir_x0) / WINDOW_WIDTH;
            double floor_step_y = row_distance * (ray_dir_y1 - ray_dir_y0) / WINDOW_WIDTH;

            double floor_x = game->player.pos_x + row_distance * ray_dir_x0;
            double floor_y = game->player.pos_y + row_distance * ray_dir_y0;

            int ceiling_color = 0x00AAAAAA;

            if (game->fog_level > 0 && row_distance > floor_fog_start)
            {
                double ceiling_fog = (row_distance - floor_fog_start) / (game->view_distance - floor_fog_start);
                if (ceiling_fog > 1) ceiling_fog = 1;
                int r = ((ceiling_color & 0xFF0000) >> 16) * (1 - ceiling_fog) + ((0x808080 & 0xFF0000) >> 16) * ceiling_fog;
                int g = ((ceiling_color & 0x00FF00) >> 8) * (1 - ceiling_fog) + ((0x808080 & 0x00FF00) >> 8) * ceiling_fog;
                int b = (ceiling_color & 0x0000FF) * (1 - ceiling_fog) + (0x808080 & 0x0000FF) * ceiling_fog;
                ceiling_color = (r << 16) | (g << 8) | b;
            }

            put_pixel(game, x, y, ceiling_color);
        }

        // Dessin du sol avec brouillard
        for (int y = draw_end; y < WINDOW_HEIGHT; y++)
        {
            double ray_dir_x0 = game->player.dir_x - game->player.plane_x;
            double ray_dir_y0 = game->player.dir_y - game->player.plane_y;
            double ray_dir_x1 = game->player.dir_x + game->player.plane_x;
            double ray_dir_y1 = game->player.dir_y + game->player.plane_y;

            int p = y - WINDOW_HEIGHT / 2;
            double pos_z = 0.5 * WINDOW_HEIGHT;
            double row_distance = pos_z / p;

            double floor_step_x = row_distance * (ray_dir_x1 - ray_dir_x0) / WINDOW_WIDTH;
            double floor_step_y = row_distance * (ray_dir_y1 - ray_dir_y0) / WINDOW_WIDTH;

            double floor_x = game->player.pos_x + row_distance * ray_dir_x0;
            double floor_y = game->player.pos_y + row_distance * ray_dir_y0;

            int floor_color = 0x00555555;

            if (game->fog_level > 0 && row_distance > floor_fog_start)
            {
                double floor_fog = (row_distance - floor_fog_start) / (game->view_distance - floor_fog_start);
                if (floor_fog > 1) floor_fog = 1;
                int r = ((floor_color & 0xFF0000) >> 16) * (1 - floor_fog) + ((0x808080 & 0xFF0000) >> 16) * floor_fog;
                int g = ((floor_color & 0x00FF00) >> 8) * (1 - floor_fog) + ((0x808080 & 0x00FF00) >> 8) * floor_fog;
                int b = (floor_color & 0x0000FF) * (1 - floor_fog) + (0x808080 & 0x0000FF) * floor_fog;
                floor_color = (r << 16) | (g << 8) | b;
            }

            put_pixel(game, x, y, floor_color);
        }
    }
}

/* Boucle de rendu */
int render(t_game *game)
{
    if (game->game_state == GAME_STATE_MENU)
    {
        draw_menu(game);
        return (0);
    }

    move_player(game);
    raycasting(game);

    // Appliquer le fog si nécessaire
    if (game->fog_intensity > 0)
    {
        for (int y = 0; y < WINDOW_HEIGHT; y++)
            for (int x = 0; x < WINDOW_WIDTH; x++)
            {
                int current = *(unsigned int*)(game->addr +
                    (y * game->line_length + x * (game->bits_per_pixel / 8)));
                int fog_color = 0x808080;  // Gris
                int fogged = current * (1 - game->fog_intensity) +
                            fog_color * game->fog_intensity;
                put_pixel(game, x, y, fogged);
            }
    }

    mlx_put_image_to_window(game->mlx, game->win, game->img, 0, 0);

    update_game_state(game);
    draw_timer(game);
	update_minimap(game);
	mlx_put_image_to_window(game->mlx, game->win, game->minimap->img, 10, 10);

    if (game->game_state == GAME_STATE_GAMEOVER)
        draw_gameover(game);

    return (0);
}

int blend_color(int color1, int color2, double factor)
{
    int r = ((color1 & 0xFF0000) >> 16) * factor + ((color2 & 0xFF0000) >> 16) * (1 - factor);
    int g = ((color1 & 0x00FF00) >> 8) * factor + ((color2 & 0x00FF00) >> 8) * (1 - factor);
    int b = (color1 & 0x0000FF) * factor + (color2 & 0x0000FF) * (1 - factor);
    return (r << 16) | (g << 8) | b;
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   minimap.c                                          :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: dloisel <dloisel@student.42.fr>            +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/12/23 00:31:19 by dloisel           #+#    #+#             */
/*   Updated: 2024/12/28 00:34:46 by dloisel          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../../includes/cub3d.h"

// Fonctions pour la minimap
void init_minimap(t_game *game)
{
	game->minimap = malloc(sizeof(t_minimap));
	if (!game->minimap)
		return ;

	game->minimap->width = MINIMAP_WIDTH;
	game->minimap->height = MINIMAP_HEIGHT;
	game->minimap->img = mlx_new_image(game->mlx, MINIMAP_WIDTH, MINIMAP_HEIGHT);
	game->minimap->addr = mlx_get_data_addr(game->minimap->img,
		&game->minimap->bits_per_pixel,
		&game->minimap->line_length,
		&game->minimap->endian);
}

static void put_pixel_minimap(t_minimap *minimap, int x, int y, int color)
{
	char    *dst;

	if (x >= 0 && x < minimap->width && y >= 0 && y < minimap->height)
	{
		dst = minimap->addr + (y * minimap->line_length + x * (minimap->bits_per_pixel / 8));
		*(unsigned int*)dst = color;
	}
}

static void apply_gaussian_blur(t_minimap *minimap)
{
	float kernel[MINIMAP_BLUR_RADIUS * 2 + 1][MINIMAP_BLUR_RADIUS * 2 + 1];
	float sigma = MINIMAP_BLUR_SIGMA;
	float sum = 0.0f;
	char *temp = malloc(minimap->height * minimap->line_length);

	if (!temp)
		return;

	// Création du kernel gaussien
	for (int y = -MINIMAP_BLUR_RADIUS; y <= MINIMAP_BLUR_RADIUS; y++)
	{
		for (int x = -MINIMAP_BLUR_RADIUS; x <= MINIMAP_BLUR_RADIUS; x++)
		{
			float value = exp(-(x * x + y * y) / (2.0f * sigma * sigma));
			kernel[y + MINIMAP_BLUR_RADIUS][x + MINIMAP_BLUR_RADIUS] = value;
			sum += value;
		}
	}

	// Normalisation du kernel
	for (int y = 0; y < MINIMAP_BLUR_RADIUS * 2 + 1; y++)
		for (int x = 0; x < MINIMAP_BLUR_RADIUS * 2 + 1; x++)
			kernel[y][x] /= sum;

	memcpy(temp, minimap->addr, minimap->height * minimap->line_length);

	// Application du flou
	for (int y = MINIMAP_BLUR_RADIUS; y < minimap->height - MINIMAP_BLUR_RADIUS; y++)
	{
		for (int x = MINIMAP_BLUR_RADIUS; x < minimap->width - MINIMAP_BLUR_RADIUS; x++)
		{
			float r = 0, g = 0, b = 0;
			for (int ky = -MINIMAP_BLUR_RADIUS; ky <= MINIMAP_BLUR_RADIUS; ky++)
			{
				for (int kx = -MINIMAP_BLUR_RADIUS; kx <= MINIMAP_BLUR_RADIUS; kx++)
				{
					int px = x + kx;
					int py = y + ky;
					int pixel_pos = py * minimap->line_length + px * (minimap->bits_per_pixel / 8);
					float k = kernel[ky + MINIMAP_BLUR_RADIUS][kx + MINIMAP_BLUR_RADIUS];

					b += (unsigned char)temp[pixel_pos] * k;
					g += (unsigned char)temp[pixel_pos + 1] * k;
					r += (unsigned char)temp[pixel_pos + 2] * k;
				}
			}
			put_pixel_minimap(minimap, x, y, ((int)r << 16) | ((int)g << 8) | (int)b);
		}
	}
	free(temp);
}

void update_minimap(t_game *game)
{
	if (!game->minimap)
		return;

	// Taille d'une cellule de la minimap
	int cell_size = 20;  // Taille fixe pour chaque cellule

	// Effacer la minimap
	ft_memset(game->minimap->addr, 0,
		game->minimap->height * game->minimap->line_length);

	// Position centrale de la minimap
	int center_x = game->minimap->width / 2;
	int center_y = game->minimap->height / 2;

	// Nombre de cellules visibles
	int cells_x = game->minimap->width / cell_size;
	int cells_y = game->minimap->height / cell_size;

	// Pour chaque cellule visible dans la minimap
	for (int y = -cells_y/2; y <= cells_y/2; y++)
	{
		for (int x = -cells_x/2; x <= cells_x/2; x++)
		{
			// Calculer la position dans la map du jeu
			int map_x = floor(game->player.pos_y) + x;
			int map_y = floor(game->player.pos_x) + y;

			// Position dans la minimap
			int mini_x = center_x + (x * cell_size);
			int mini_y = center_y + (y * cell_size);

			// Vérifier si la position est dans les limites de la map
			if (map_x >= 0 && map_x < game->map.width &&
				map_y >= 0 && map_y < game->map.height)
			{
				int color;
				if (game->map.fullmap[map_y][map_x] == '1')
					color = 0xFFFFFF;  // Murs en blanc
				else if (game->map.fullmap[map_y][map_x] == '0' ||
						game->map.fullmap[map_y][map_x] == 'N' ||
						game->map.fullmap[map_y][map_x] == 'S' ||
						game->map.fullmap[map_y][map_x] == 'E' ||
						game->map.fullmap[map_y][map_x] == 'W')
					color = 0x444444;  // Sol en gris
				else
					color = 0x000000;  // Vide en noir

				// Dessiner la cellule avec une bordure
				for (int py = 0; py < cell_size; py++)
				{
					for (int px = 0; px < cell_size; px++)
					{
						int draw_x = mini_x - (cell_size / 2) + px;
						int draw_y = mini_y - (cell_size / 2) + py;
						if (draw_x >= 0 && draw_x < game->minimap->width &&
							draw_y >= 0 && draw_y < game->minimap->height)
						{
							// Ajouter une bordure d'un pixel
							if (px == 0 || px == cell_size-1 || py == 0 || py == cell_size-1)
								put_pixel_minimap(game->minimap, draw_x, draw_y, 0x333333);
							else
								put_pixel_minimap(game->minimap, draw_x, draw_y, color);
						}
					}
				}
			}
		}
	}

	// Dessiner le joueur au centre exact
	int player_size = 4;

	for (int py = -player_size; py <= player_size; py++)
	{
		for (int px = -player_size; px <= player_size; px++)
		{
			if (px * px + py * py <= player_size * player_size)
			{
				put_pixel_minimap(game->minimap,
					center_x + px,
					center_y + py,
					0xFF0000);
			}
		}
	}

	// Direction du joueur
	int dir_x = (center_x + game->player.dir_y * cell_size);
	int dir_y = (center_y + game->player.dir_x * cell_size);

	// Tracer la ligne de direction
	int dx = dir_x - center_x;
	int dy = dir_y - center_y;
	int steps = sqrt(dx * dx + dy * dy);

	if (steps > 0)
	{
		double x_inc = dx / (double)steps;
		double y_inc = dy / (double)steps;
		double x = center_x;
		double y = center_y;

		for (int i = 0; i < steps; i++)
		{
			if (x >= 0 && x < game->minimap->width &&
				y >= 0 && y < game->minimap->height)
			{
				put_pixel_minimap(game->minimap, round(x), round(y), 0xFF0000);
			}
			x += x_inc;
			y += y_inc;
		}
	}
}
//pixels.c

#include "../../includes/cub3d.h"

/* Fonction pour obtenir la couleur d'un pixel dans une texture */
int get_texture_color(t_texture *texture, int x, int y)
{
    if (x < 0 || x >= texture->width || y < 0 || y >= texture->height)
        return (0);
    return (texture->data[y * texture->width + x]);
}

/* Fonction pour mettre un pixel dans l'image */
void put_pixel(t_game *game, int x, int y, int color)
{
    char *dst;

    if (!game || !game->addr || x < 0 || x >= WINDOW_WIDTH || y < 0 || y >= WINDOW_HEIGHT)
        return;

    // Calculer l'offset en octets
    long offset = y * game->line_length + x * (game->bits_per_pixel / 8);
    
    // Vérifier que l'offset ne dépasse pas la taille de l'image
    if (offset >= WINDOW_WIDTH * WINDOW_HEIGHT * (game->bits_per_pixel / 8))
        return;

    dst = game->addr + offset;
    *(unsigned int*)dst = color;
}//textures.c

#include "../../includes/cub3d.h"

/* Fonction pour charger une texture */
int load_texture(t_game *game, t_texture *texture, char *path)
{
    texture->img = mlx_xpm_file_to_image(game->mlx, path,
                                        &texture->width, &texture->height);
    if (!texture->img)
        return (0);
    texture->data = (int *)mlx_get_data_addr(texture->img, &texture->bits_per_pixel,
                                            &texture->line_length, &texture->endian);
    return (1);
}

/* Fonction pour charger toutes les textures */
int load_textures(t_game *game)
{
    if (!load_texture(game, &game->textures.north, game->map.no_texture))
        return (0);
    if (!load_texture(game, &game->textures.south, game->map.so_texture))
        return (0);
    if (!load_texture(game, &game->textures.east, game->map.ea_texture))
        return (0);
    if (!load_texture(game, &game->textures.west, game->map.we_texture))
        return (0);
    return (1);
}
#include "../../includes/cub3d.h"

void draw_text_center(t_game *game, char *text, int y, int color)
{
    int text_width = ft_strlen(text) * 10;  // Estimation approximative
    int x = (WINDOW_WIDTH - text_width) / 2;
    mlx_string_put(game->mlx, game->win, x, y, color, text);
}

void draw_menu(t_game *game)
{
    // Fond noir
    for (int y = 0; y < WINDOW_HEIGHT; y++)
        for (int x = 0; x < WINDOW_WIDTH; x++)
            put_pixel(game, x, y, 0x000000);
            
    mlx_put_image_to_window(game->mlx, game->win, game->img, 0, 0);
    draw_text_center(game, "JOUER", WINDOW_HEIGHT / 2, 0xFFFFFF);
    draw_text_center(game, "Appuyez sur ENTREE pour commencer", 
                    WINDOW_HEIGHT / 2 + 40, 0xFFFFFF);
}

void draw_gameover(t_game *game)
{
    // Fond semi-transparent
    for (int y = 0; y < WINDOW_HEIGHT; y++)
        for (int x = 0; x < WINDOW_WIDTH; x++)
        {
            int current = *(unsigned int*)(game->addr + 
                (y * game->line_length + x * (game->bits_per_pixel / 8)));
            int blended = ((current & 0xFEFEFE) >> 1) | 0x800000;
            put_pixel(game, x, y, blended);
        }
    
    mlx_put_image_to_window(game->mlx, game->win, game->img, 0, 0);
    draw_text_center(game, "PERDU", WINDOW_HEIGHT / 2, 0xFF0000);
}

void draw_timer(t_game *game)
{
    int remaining = INITIAL_TIME - (game->current_time - game->start_time);
    if (remaining < 0) remaining = 0;
    
    char timer_text[6];
    snprintf(timer_text, 6, "%02d:%02d", remaining / 60, remaining % 60);
    
    // Position en bas à droite avec une marge de 20 pixels
    int x = WINDOW_WIDTH - 120; 
    int y = WINDOW_HEIGHT - 40;
    
    // et couleur rouge (0xFF0000)
    mlx_string_put(game->mlx, game->win, x, y, 0xFF0000, timer_text);
}